#pragma once

//This code was generated by phind AI at phind.com and will be removed after inspection
// This is simply for refrence and storage purposes

#include <cstdint>

// Macros for bitwise operations
#define BIT_SET(value, bit) ((value) |= (1ULL << (bit)))
#define BIT_CLEAR(value, bit) ((value) &= ~(1ULL << (bit)))
#define BIT_FLIP(value, bit) ((value) ^= (1ULL << (bit)))

// Macros for type-specific conversions
#define INT_TO_BITS(value) ((uint64_t)(value))
#define BITS_TO_INT(bits) ((int32_t)(bits))

// Compile-time bitwise operations (constexpr functions)
template<typename T>
constexpr T bitwise_and(T a, T b) {
    return static_cast<T>(static_cast<uint64_t>(a) & static_cast<uint64_t>(b));
}

template<typename T>
constexpr T bitwise_or(T a, T b) {
    return static_cast<T>(static_cast<uint64_t>(a) | static_cast<uint64_t>(b));
}

template<typename T>
constexpr T bitwise_xor(T a, T b) {
    return static_cast<T>(static_cast<uint64_t>(a) ^ static_cast<uint64_t>(b));
}

template<typename T>
constexpr T bitwise_not(T value) {
    return ~value;
}

#include "bitwise_macros.h"

/**
* @brief class for representing and handling integer types to help with bitwise truncation
*/
template <typename T>
class integers{
  private:
    using types = typename std::variant<uint8_t*, uint16_t>; //more types added later
    integers(integers&&) = delete;
    integers() = delete;
    
    // Helper function for bitwise operations
    static constexpr T bit_operation(T value, int operation) {
        switch(operation) {
            case 0: return bitwise_and(value, T(0xFFFFFFFF));
            case 1: return bitwise_or(value, T(0xFFFFFFFF));
            case 2: return bitwise_xor(value, T(0xFFFFFFFF));
            default: return bitwise_not(value);
        }
    }

  public:
    /** @brief return type should be a bit value of types */
    using bit_return_type = std::bit_cast<types>
    types operator()(types input) {
        // Perform bitwise operation based on input type
        uint64_t value = INT_TO_BITS(*input);
        
        switch (std::variant_size_v<types>) {
            case 1: return std::bit_cast<uint8_t*>(bit_operation(value, 0));
            case 2: return std::bit_cast<uint16_t*>(bit_operation(value, 0));
            default: throw std::runtime_error("Unsupported variant size");
        }
    }

    types operator bitwise=(types input) {
        // Convert input to bit representation
        uint64_t value = INT_TO_BITS(*input);
        
        // Perform bitwise operation
        value = bit_operation(value, 0); // Use AND for truncation
        
        switch (std::variant_size_v<types>) {
            case 1: return std::bit_cast<uint8_t*>(value & 0xFF);
            case 2: return std::bit_cast<uint16_t*>(value & 0xFFFF);
            default: throw std::runtime_error("Unsupported variant size");
        }
    }
};
